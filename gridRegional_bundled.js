export default async function gridRegional (apiConfig) { const ne = Object.defineProperty; const ft = (t) => (e) => { const a = t[e]; if (a) return a(); throw new Error("Module not found in bundle: " + e); }; const l = (t, e) => () => (t && (e = t(t = 0)), e); const u = (t, e) => { for (const a in e)ne(t, a, { "get": e[a], "enumerable": !0 }); }; const I = {}; u(I, { "errorStatus": () => ie }); let ie; const S = l(() => { ie = { "status": !0, "lastError": {}, "errorList": [] }; }); const wt = {}; u(wt, { "formError": () => re }); async function re (t, e) { let { "errorStatus": a } = await Promise.resolve().then(() => (S(), I)); e = e === "unknown" ? "unknown" : `${e}.js`; let n = new Error().stack.toString().match(/([A-Za-z0-9_$-]+) \(([^)]+)\)/g); n.splice(0, 2); let s = []; for await (let m of n) { let c = m.split(" "); let p = c[0]; let h = c[1].replace(/[()]/g, "").split("/"); let y = h[h.length - 1].split(":")[0]; s.push({ "function": p, "file": y }); } let o = { "code": t, "functionName": s[0].function, "currentName": s[0].file, "originalName": e }; console.log(o), t !== "warning" && (a.status = !1), a.lastError = o, a.errorList.push(o); } const dt = l(() => {}); const b = {}; u(b, { "patterns": () => se }); let se; const x = l(() => { se = { "pattern1": /[^a-zA-Z]+/g, "pattern2": /\s{2,}/g, "pattern3": /\s/g, "pattern4": /^[A-Za-z0-9]+$/i, "pattern5": /^[A-Za-z0-9\s]+$/i, "pattern6": /([Zz]|[+-]\d{2}:\d{2})$/, "pattern7": /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])(?:[Tt ]([01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?)?(?:[Zz]|[+-][01]\d:[0-5]\d)?$/, "pattern8": /^(0[1-9]|[12]\d|3[01])-(0[1-9]|1[0-2])-(\d{4})(?:[Tt ]([01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?)?(?:[Zz]|[+-][01]\d:[0-5]\d)?$/, "pattern9": /^\d+(\.\d+)?$/, "pattern10": /^[\p{L}\p{M}][\p{L}\p{M}\s."???\-,&()/]*$/u }; }); const k = {}; u(k, { "typeID": () => oe }); async function oe (t) { let { "patterns": e } = await Promise.resolve().then(() => (x(), b)); return Object.prototype.toString.call(t).split(" ")[1].replace(e.pattern1, "").toLowerCase(); } const N = l(() => {}); const R = {}; u(R, { "spaceFormat": () => ce }); async function ce (t, e) { let { "patterns": a } = await Promise.resolve().then(() => (x(), b)); return e === "singleSpace" ? String(t).replace(a.pattern2, " ") : e === "noSpace" ? String(t).replace(a.pattern3, "") : (await errorHandle(1845, "spaceFormat"), !1); } const j = l(() => {}); const L = {}; u(L, { "isNully": () => le }); async function le (t) { let { "typeID": e } = await Promise.resolve().then(() => (N(), k)); let { "spaceFormat": a } = await Promise.resolve().then(() => (j(), R)); switch (await e(t)) { case "number": return isNaN(t); case "null": case "undefined": return !0; case "string": return (await a(String(t), "singleSpace")).trim().length === 0; default: return !1; } } const v = l(() => {}); const f = {}; u(f, { "errorHandle": () => ue }); async function ue (t, e) { let { "errorStatus": a } = await Promise.resolve().then(() => (S(), I)); let { "formError": r } = await Promise.resolve().then(() => (dt(), wt)); let { "isNully": i } = await Promise.resolve().then(() => (v(), L)); if (await i(t)) await r("unknown", "unknown"); else { if (t === "status") return !!a.status; (await i(e)) || (t === "warning" ? await r(t, e) : t >= 1111 && t <= 9999 ? await r(t, e) : await r("unknown", "unknown")); } } const w = l(() => {}); const gt = {}; u(gt, { "conditionString": () => me }); async function me (t, e) { let { "typeID": a } = await Promise.resolve().then(() => (N(), k)); let { "spaceFormat": r } = await Promise.resolve().then(() => (j(), R)); if ((await a(t)) === "string") { let i = await r(String(t), "singleSpace"); switch (String(e)) { case "1": return !0; default: return i.trim().length > 0; } } else return !1; } const ht = l(() => {}); const yt = {}; u(yt, { "conditionArray": () => pe }); async function pe (t, e) { let { "typeID": a } = await Promise.resolve().then(() => (N(), k)); if ((await a(t)) === "array") switch (String(e)) { case "1": return !0; default: return t.length !== 0; } else return !1; } const kt = l(() => {}); const Nt = {}; u(Nt, { "conditionObject": () => fe }); async function fe (t, e) { let { "typeID": a } = await Promise.resolve().then(() => (N(), k)); if ((await a(t)) === "object") switch (String(e)) { case "1": return !0; default: return Object.keys(t).length > 0 && Object.values(t).length > 0; } else return !1; } const bt = l(() => {}); const xt = {}; u(xt, { "conditionNumber": () => we }); async function we (t, e) { let { "typeID": a } = await Promise.resolve().then(() => (N(), k)); if ((await a(t)) === "number") switch (String(e)) { case "1": return !0; default: return isNaN(t) === !1; } else return !1; } const Rt = l(() => {}); const jt = {}; u(jt, { "conditionBoolean": () => de }); async function de (t) { let { "typeID": e } = await Promise.resolve().then(() => (N(), k)); return (await e(t)) === "boolean"; } const It = l(() => {}); const St = {}; u(St, { "conditionUndefined": () => ge }); async function ge (t) { let { "typeID": e } = await Promise.resolve().then(() => (N(), k)); return (await e(t)) === "undefined"; } const Lt = l(() => {}); const vt = {}; u(vt, { "conditionNull": () => he }); async function he (t) { let { "typeID": e } = await Promise.resolve().then(() => (N(), k)); return (await e(t)) === "null"; } const Ot = l(() => {}); const d = {}; u(d, { "conditionCheck": () => ye }); async function ye (t, e, a) { let { "conditionString": r } = await Promise.resolve().then(() => (ht(), gt)); let { "conditionArray": i } = await Promise.resolve().then(() => (kt(), yt)); let { "conditionObject": n } = await Promise.resolve().then(() => (bt(), Nt)); let { "conditionNumber": s } = await Promise.resolve().then(() => (Rt(), xt)); let { "conditionBoolean": o } = await Promise.resolve().then(() => (It(), jt)); let { "conditionUndefined": m } = await Promise.resolve().then(() => (Lt(), St)); let { "conditionNull": c } = await Promise.resolve().then(() => (Ot(), vt)); switch (e) { case "string": return await r(t, a); case "array": return await i(t, a); case "object": return await n(t, a); case "number": return await s(t, a); case "boolean": return await o(t); case "undefined": return await m(t); case "null": return await c(t); } } const g = l(() => {}); const Ct = {}; u(Ct, { "checkResult": () => ke }); async function ke (t, e) { let { "errorHandle": a } = await Promise.resolve().then(() => (w(), f)); let r = t?.headers.get("content-type"); if (r && r?.includes("application/json")) try { let i = JSON.parse(e); return i || (await a(5468, "checkResult"), !1); } catch { return await a(4366, "checkResult"), !1; } else return await a(4337, "checkResult"), !1; } const Dt = l(() => {}); const Ht = {}; u(Ht, { "attemptFetch": () => Ne }); async function Ne (t) { let { "checkResult": e } = await Promise.resolve().then(() => (Dt(), Ct)); let { "errorHandle": a } = await Promise.resolve().then(() => (w(), f)); let r = 5; let i = !1; for (;r-- && i === !1;) { try { let n = await fetch(t); if (n.ok) { i = !0; let s = await n.text(); return await e(n, s); } else await a("warning", "attemptFetch"); } catch { if (r === 0) return await a(9858, "attemptFetch"), !1; } await new Promise((n) => setTimeout(n, 200)); } } const Ft = l(() => {}); const $t = {}; u($t, { "fetchRegional": () => be }); async function be (t) { let { "conditionCheck": e } = await Promise.resolve().then(() => (g(), d)); let { "errorHandle": a } = await Promise.resolve().then(() => (w(), f)); let { "attemptFetch": r } = await Promise.resolve().then(() => (Ft(), Ht)); if (await e(t, "object")) { let i; let n = "https://api.carbonintensity.org.uk/regional"; let s; let o; let m; let c = t.region === "all" ? "all" : "specified"; if (c === "all")s = ""; else if (c === "specified") { switch (t.region) { case "england": { m = "15"; break; } case "scotland": { m = "16"; break; } case "wales": { m = "17"; break; } }s = `/regionid/${m}`; }t.mode === "current" ? o = "" : t.mode === "custom" && (o = `/intensity/${t.startDate}/${t.endDate}`), !o && s ? i = encodeURI(n + s) : !s && o ? i = encodeURI(n + o) : o && s ? i = encodeURI(n + o + s) : !o && !s && (i = encodeURI(n)); let p = await r(i); return (await e(p, "object")) ? p : (await a(7214, "fetchRegional"), !1); } else return await a(5848, "fetchRegional"), !1; } const Pt = l(() => {}); const Vt = {}; u(Vt, { "flatternObject": () => At }); async function At (t, e = "", a = {}, r = new Set) { for await (let i of Object.keys(t)) { let n = t[i]; if (n && typeof n == "object" && !Array.isArray(n)) await At(n, i, a, r); else { let s = r.has(i) ? `${e}.${i}` : i; a[s] = n, r.add(i); } } return a; } const Et = l(() => {}); const F = {}; u(F, { "dateFormat": () => xe }); async function xe (t) { let { "patterns": e } = await Promise.resolve().then(() => (x(), b)); let { "errorHandle": a } = await Promise.resolve().then(() => (w(), f)); let r = t.replace(e.pattern7, ""); if (e.pattern8.test(r)) { let i = r.split("-").reverse().join("-"); return (new Date(i).getDate() ? i : !1) ? i : (await a(6902, "dateFormat"), !1); } else return await a(6397, "dateFormat"), !1; } const $ = l(() => {}); const P = {}; u(P, { "dateInput": () => Re }); async function Re (t) { let { "spaceFormat": e } = await Promise.resolve().then(() => (j(), R)); let { "errorHandle": a } = await Promise.resolve().then(() => (w(), f)); let { "patterns": r } = await Promise.resolve().then(() => (x(), b)); let { "dateFormat": i } = await Promise.resolve().then(() => ($(), F)); let n; if (r.pattern7.test(t) || r.pattern8.test(t)) { let s = t.replace(r.pattern6, ""); r.pattern8.test(t) ? n = await i(s) : n = s; } else return await a(3752, "dateInput"), !1; if (n) { let s = (await e(String(n), "singleSpace")).toLowerCase(); return s || (await a(2274, "dateInput"), !1); } else return await a(1123, "dateInput"), !1; } const A = l(() => {}); const O = {}; u(O, { "patternTest": () => je }); async function je (t, e, a, r) { let { "errorHandle": i } = await Promise.resolve().then(() => (w(), f)); let { "patterns": n } = await Promise.resolve().then(() => (x(), b)); return n[e].test(t) ? t : (await i(a, r), !1); } const C = l(() => {}); const V = {}; u(V, { "modeInput": () => Ie }); async function Ie (t) { let { "spaceFormat": e } = await Promise.resolve().then(() => (j(), R)); let { "errorHandle": a } = await Promise.resolve().then(() => (w(), f)); let { "patternTest": r } = await Promise.resolve().then(() => (C(), O)); let i = await r(t, "pattern4", 6664, "modeInput"); if (i) { let n = (await e(String(i), "singleSpace")).toLowerCase(); return n ? n === "custom" || n === "current" ? n : (await a(3772, "modeInput"), !1) : (await a(4283, "modeInput"), !1); } } const E = l(() => {}); const z = {}; u(z, { "regionInput": () => Se }); async function Se (t) { let { "spaceFormat": e } = await Promise.resolve().then(() => (j(), R)); let { "errorHandle": a } = await Promise.resolve().then(() => (w(), f)); let { "patternTest": r } = await Promise.resolve().then(() => (C(), O)); let i = await r(t, "pattern4", 5556, "regionInput"); if (i) { let n = (await e(String(i), "singleSpace")).toLowerCase(); if (n) switch (n) { case "england": case "scotland": case "wales": return n; default: return await a(8282, "regionInput"), !1; } else return await a(3577, "regionInput"), !1; } } const K = l(() => {}); const zt = {}; u(zt, { "callObject": () => Le }); async function Le (t, e) { let { "conditionCheck": a } = await Promise.resolve().then(() => (g(), d)); let { "errorHandle": r } = await Promise.resolve().then(() => (w(), f)); let i = (await a(t, "object")) ? t : !1; let n = (await a(e, "string")) ? e : !1; if (i && n) try { return await e.split(".").reduce(async (s, o) => s[o], t); } catch { return await r(8260, "callObject"), !1; } else return await r(7093, "callObject"), !1; } const Kt = l(() => {}); const U = {}; u(U, { "manageBase": () => ve }); async function ve (t, e) { let { "errorHandle": a } = await Promise.resolve().then(() => (w(), f)); let { "callObject": r } = await Promise.resolve().then(() => (Kt(), zt)); let { "conditionCheck": i } = await Promise.resolve().then(() => (g(), d)); let n = {}; let s = {}; if (!(await a("status"))) return !1; if (i(t, "object")) { for await (let o of Object.keys(e)) { if (!(await a("status"))) return !1; n[o] = !1; let m = await r(t, o); if (i(m, "string")) { let c = m.toLowerCase(); let p = await e[o](c); p && (n[o] = !0, s[o] = p); } else return await a(4250, "manageBase"), !1; } return Object.values(n).includes(!1) ? (await a(9546, "manageBase"), !1) : s; } } const Z = l(() => {}); const B = {}; u(B, { "baseInput": () => Oe }); async function Oe (t) { let { "dateInput": e } = await Promise.resolve().then(() => (A(), P)); let { "modeInput": a } = await Promise.resolve().then(() => (E(), V)); let { "regionInput": r } = await Promise.resolve().then(() => (K(), z)); let { "manageBase": i } = await Promise.resolve().then(() => (Z(), U)); return await i(t, { "mode": a, "region": r, "startDate": e, "endDate": e }); } const M = l(() => {}); const T = {}; u(T, { "objectLoop": () => Ut }); async function Ut (t) { let { "typeID": e } = await Promise.resolve().then(() => (N(), k)); let { "conditionCheck": a } = await Promise.resolve().then(() => (g(), d)); let { "errorHandle": r } = await Promise.resolve().then(() => (w(), f)); if (await r("status")) { if ((await a(t, "object")) === !1) return 0; let i = 0; let n = Object.keys(t); for await (let s of n) { let o = t[s]; let m = await e(o); let c; switch (m) { case "string": case "number": case "bigint": case "boolean": case "undefined": case "array": case "null": { c = await a(o, m, 1); break; } default: c = !1; }(await a(o, "object")) ? i += await Ut(o) : c && (i += 1); } return i; } else return await r(6030, "objectLoop"), !1; } const J = l(() => {}); const _ = {}; u(_, { "resultObj": () => Ce }); async function Ce (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), f)); let a = String(t.itemData.altName); let r = t.value; let i = await t.validateImport[t.validateValue](a, r, t.nameImport[t.nameValue]); if (i) { let n = t.result; for await (let s of t.path) if (await e("status")) { let o = s; if (t.parentNames.includes(o)) { let m = t.parentList[t.parentNames.indexOf(o)]; m.used && (o = m.altName); }n[o] ? n = n[o] : n = n[o] = {}; } else return await e(5785, "resultObj"), !1; return n[t.itemData.altName] = i, t.result; } else return await e(3149, "resultObj"), !1; } const q = l(() => {}); const Zt = {}; u(Zt, { "checkRegional": () => De }); async function De (t, e, a) { let { "isNully": r } = await Promise.resolve().then(() => (v(), L)); let { "patternTest": i } = await Promise.resolve().then(() => (C(), O)); let { "patterns": n } = await Promise.resolve().then(() => (x(), b)); if (await r(e)) return "No Value"; switch (e = String(e), t) { case a.children.item1.name.altName: case a.children.item2.name.altName: { let s = e.replace(n.pattern6, ""); return await i(s, "pattern7", 6043, "checkRegional"); } case a.children.item3.name.altName: case a.children.item4.name.altName: case a.children.item5.name.altName: case a.children.item6.name.altName: case a.children.item7.name.altName: case a.children.item8.name.altName: case a.children.item9.name.altName: case a.children.item10.name.altName: case a.children.item11.name.altName: case a.children.item13.name.altName: case a.children.item15.name.altName: return await i(e, "pattern9", 5086, "checkRegional"); case a.children.item12.name.altName: case a.children.item14.name.altName: case a.children.item16.name.altName: return await i(e, "pattern10", 6858, "checkRegional"); } } const Bt = l(() => {}); const G = {}; u(G, { "formatItem": () => He }); async function He (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), f)); let { "conditionCheck": a } = await Promise.resolve().then(() => (g(), d)); if (await e("status")) { let r = t.generationmix; return (await a(r, "array")) ? (t.generationmix = await r.reduce(function (i, n) { return i[String(n.fuel)] = String(n.perc), i; }, {}), t) : (await e(3583, "formatItem"), !1); } else return await e(9432, "formatItem"), !1; } const Q = l(() => {}); const W = {}; u(W, { "formatLoop": () => Fe }); async function Fe (t, e) { let { "conditionCheck": a } = await Promise.resolve().then(() => (g(), d)); let { "errorHandle": r } = await Promise.resolve().then(() => (w(), f)); let { "formatItem": i } = await Promise.resolve().then(() => (Q(), G)); let n = e === "custom" ? t : t[0]; let s = n.data; if (await r("status")) if (await a(s, "array")) { let o = {}; let m = 0; for await (let c of Object.keys(s)) { let p = s[c]; if (p !== void 0)o[`object${m}`] = await i(p); else return await r(1445, "formatLoop"), !1; m++; } return n.data = o, n; } else return await r(1525, "formatLoop"), !1; else return await r(3834, "formatLoop"), !1; } const X = l(() => {}); const Y = {}; u(Y, { "regionalNames": () => $e }); let $e; const tt = l(() => { $e = { "parents": {}, "children": { "item1": { "name": { "original": "from", "altName": "from" }, "used": !0, "validate": "checkRegional" }, "item2": { "name": { "original": "to", "altName": "to" }, "used": !0, "validate": "checkRegional" }, "item3": { "name": { "original": "biomass", "altName": "biomass" }, "used": !0, "validate": "checkRegional" }, "item4": { "name": { "original": "coal", "altName": "coal" }, "used": !0, "validate": "checkRegional" }, "item5": { "name": { "original": "gas", "altName": "gas" }, "used": !0, "validate": "checkRegional" }, "item6": { "name": { "original": "hydro", "altName": "hydro" }, "used": !0, "validate": "checkRegional" }, "item7": { "name": { "original": "imports", "altName": "imports" }, "used": !0, "validate": "checkRegional" }, "item8": { "name": { "original": "nuclear", "altName": "nuclear" }, "used": !0, "validate": "checkRegional" }, "item9": { "name": { "original": "other", "altName": "other" }, "used": !0, "validate": "checkRegional" }, "item10": { "name": { "original": "solar", "altName": "solar" }, "used": !0, "validate": "checkRegional" }, "item11": { "name": { "original": "wind", "altName": "wind" }, "used": !0, "validate": "checkRegional" }, "item12": { "name": { "original": "dnoregion", "altName": "longName" }, "used": !0, "validate": "checkRegional" }, "item13": { "name": { "original": "forecast", "altName": "forecast" }, "used": !0, "validate": "checkRegional" }, "item14": { "name": { "original": "index", "altName": "index" }, "used": !0, "validate": "checkRegional" }, "item15": { "name": { "original": "regionid", "altName": "regionid" }, "used": !1, "validate": "checkRegional" }, "item16": { "name": { "original": "shortname", "altName": "shortname" }, "used": !0, "validate": "checkRegional" } } }; }); let Mt; const et = l(() => { Mt = ft({ "../manageInput/baseInput.js": () => Promise.resolve().then(() => (M(), B)), "../manageInput/dateInput.js": () => Promise.resolve().then(() => (A(), P)), "../manageInput/manageBase.js": () => Promise.resolve().then(() => (Z(), U)), "../manageInput/modeInput.js": () => Promise.resolve().then(() => (E(), V)), "../manageInput/regionInput.js": () => Promise.resolve().then(() => (K(), z)), "../manageProcess/innerLoop.js": () => Promise.resolve().then(() => (H(), D)), "../manageProcess/loopItem.js": () => Promise.resolve().then(() => (rt(), it)), "../manageProcess/objectLoop.js": () => Promise.resolve().then(() => (J(), T)), "../manageProcess/resultObj.js": () => Promise.resolve().then(() => (q(), _)), "../manageProcess/setupItem.js": () => Promise.resolve().then(() => (nt(), at)), "../manageProcess/setupLoop.js": () => Promise.resolve().then(() => (ot(), st)), "../manageRegional/checkRegional.js": () => Promise.resolve().then(() => (Bt(), Zt)), "../manageRegional/dateFormat.js": () => Promise.resolve().then(() => ($(), F)), "../manageRegional/formatItem.js": () => Promise.resolve().then(() => (Q(), G)), "../manageRegional/formatLoop.js": () => Promise.resolve().then(() => (X(), W)), "../manageRegional/getRegional.js": () => Promise.resolve().then(() => (lt(), ct)), "../manageRegional/manageRegional.js": () => Promise.resolve().then(() => (mt(), ut)), "../manageRegional/regionalNames.js": () => Promise.resolve().then(() => (tt(), Y)) }); }); let at = {}; u(at, { "setupItem": () => Pe }); async function Pe (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), f)); let { "resultObj": a } = await Promise.resolve().then(() => (q(), _)); let r = Object.keys(t.loop.storage)[0].toLowerCase(); let i = r.charAt(0).toUpperCase() + r.slice(1); let n = r + "Names"; let s = await Mt(`../manage${i}/${n}.js`); let o = t.loop.itemData.validate; let m = await Mt(`../manage${i}/${o}.js`); if (await e("status")) { let c = t.loop.path; let p = t.loop.itemData; if (Number(t.loop.childIndex) === 0 && t.loop.parent !== "" && c.length === 0 && c.push(r), p) { let h = { "itemData": p, "value": t.data.value, "nameValue": n, "nameImport": s, "validateValue": o, "validateImport": m, "parentList": t.loop.parentList, "parentNames": t.loop.parentNames, "result": t.data.result, "path": c }; let y = await a(h); return y || (await e(5825, "setupItem"), !1); } else return await e(7400, "setupItem"), !1; } else return await e(3926, "setupItem"), !1; } let nt = l(() => { et(); }); let it = {}; u(it, { "loopItem": () => Ae }); async function Ae (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), f)); let { "conditionCheck": a } = await Promise.resolve().then(() => (g(), d)); let { "setupItem": r } = await Promise.resolve().then(() => (nt(), at)); let { "innerLoop": i } = await Promise.resolve().then(() => (H(), D)); for await (let n of Object.keys(t.obj)) if (await e("status")) { let s = t.obj[n]; if ((await a(s, "array")) && (s = String(s)), !(await a(s, "object")) && !(await a(s, "array"))) { let o; let m; let c; if (t.loop1.childrenNames.includes(n)) if (m = t.loop1.childrenList[t.loop1.childrenNames.indexOf(n)], m.used) { t.parent = t.parent === "" ? Object.keys(t.storage)[0] : String(t.parent); let p = { "loop": { "parent": t.parent, "storage": t.storage, "childIndex": t.childIndex.counter, "path": t.path, "itemData": m, "parentList": t.loop1.parentList, "parentNames": t.loop1.parentNames }, "data": { "value": s, "result": t.result } }; if (c = await r(p), c)o = "validPass"; else return await e(4313, "loopItem"), !1; } else o = "ignorePass"; else o = "ignorePass"; t.loop1.itemAmount.counter++, o === "validPass" ? (m.status = !0, t.result = c, t.childIndex.counter++) : o === "ignorePass" ? t.childIndex.counter++ : await e(9561, "loopItem"); } else (await a(s, "object")) && (await i(t.loop1, s, t.storage, n, t.result, t.path.concat(n))); } else return await e(8849, "loopItem"), !1; } let rt = l(() => {}); let D = {}; u(D, { "innerLoop": () => Ve }); async function Ve (t, e, a, r = "", i = {}, n = []) { let { "errorHandle": s } = await Promise.resolve().then(() => (w(), f)); let { "loopItem": o } = await Promise.resolve().then(() => (rt(), it)); if (await s("status")) { if (await o({ "loop1": t, "obj": e, "parent": r, "path": n, "childIndex": { "counter": 0 }, "storage": a, "result": i }), Number(a.amount) === Number(t.itemAmount.counter)) { for await (let p of Object.values(t.childrenList)) if (p.used === !0 && p.used !== p.status) return !1; return i; } } else return await s(2818, "innerLoop"), !1; } let H = l(() => {}); let st = {}; u(st, { "setupLoop": () => Ee }); async function Ee (t, e) { let { "errorHandle": a } = await Promise.resolve().then(() => (w(), f)); let { "flatternObject": r } = await Promise.resolve().then(() => (Et(), Vt)); let { "innerLoop": i } = await Promise.resolve().then(() => (H(), D)); if (await a("status")) { let n = { "counter": 0 }; let s = {}; for await (let c of Object.keys(e.name))s[c] = {}, s[c].list = await Promise.all(Object.values(e.name[c]).map(async (p) => { let h = await r(p); return h.status = !1, h; })), s[c].name = await Promise.all(Object.values(s[c].list).map(async (p) => p.original)); let o = { "itemAmount": n, "childrenList": s.children.list, "childrenNames": s.children.name, "parentList": s.parents.list, "parentNames": s.parents.name }; let m = await i(o, t, e); return m || (await a(6439, "setupLoop"), !1); } else return await a(7226, "setupLoop"), !1; } let ot = l(() => {}); const Tt = {}; u(Tt, { "valueKind": () => ze }); async function ze (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), f)); let { "conditionCheck": a } = await Promise.resolve().then(() => (g(), d)); let r = {}; let i = {}; for await (let n of Object.keys(t))r[n] = !1; if (await a(t, "object")) { for await (let n of Object.keys(t)) { let s = t[n]; (await a(s.value, s.type)) && (r[n] = !0, i[n] = s.value); } return Object.values(r).includes(!1) ? (await e(9560, "valueKind"), !1) : i; } else return await e(8328, "valueKind"), !1; } const Jt = l(() => {}); const _t = {}; u(_t, { "sendProcess": () => Ke }); async function Ke (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), f)); let { "conditionCheck": a } = await Promise.resolve().then(() => (g(), d)); let { "setupLoop": r } = await Promise.resolve().then(() => (ot(), st)); let { "valueKind": i } = await Promise.resolve().then(() => (Jt(), Tt)); if (await a(t, "object")) { let n = await i(t); if (n) { let s = Object.keys(t)[0]; let o = await r(n[s], n); return o || (await e(8361, "sendProcess"), !1); } else return await e(9122, "sendProcess"), !1; } else return await e(9122, "sendProcess"), !1; } const qt = l(() => {}); let ct = {}; u(ct, { "getRegional": () => Ue }); async function Ue (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), f)); let { "fetchRegional": a } = await Promise.resolve().then(() => (Pt(), $t)); let { "sendProcess": r } = await Promise.resolve().then(() => (qt(), _t)); let { "conditionCheck": i } = await Promise.resolve().then(() => (g(), d)); let { "regionalNames": n } = await Promise.resolve().then(() => (tt(), Y)); let { "formatLoop": s } = await Promise.resolve().then(() => (X(), W)); let { "objectLoop": o } = await Promise.resolve().then(() => (J(), T)); if (!(await e("status"))) return !1; let m = await a(t); if (m) { let c = await s(m.data, t.mode); if (await i(c, "object")) { let p = await o(c); let y = await r({ "regional": { "type": "object", "value": c }, "amount": { "type": "number", "value": p }, "name": { "type": "object", "value": n } }); return y || (await e(2344, "getRegional"), !1); } else return await e(5659, "getRegional"), !1; } else return await e(5667, "getRegional"), !1; } let lt = l(() => {}); let ut = {}; u(ut, { "manageRegional": () => Ze }); async function Ze (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), f)); let { "getRegional": a } = await Promise.resolve().then(() => (lt(), ct)); if (!(await e("status"))) return !1; let r = await a(t); return r || (await e(1900, "manageRegional"), !1); } let mt = l(() => {}); const Gt = {}; u(Gt, { "getAPI": () => Be }); async function Be (t) { let { "manageRegional": e } = await Promise.resolve().then(() => (mt(), ut)); let { "errorHandle": a } = await Promise.resolve().then(() => (w(), f)); let r = await e(t); return (await a("status")) ? { "regional": r } : !1; } const Qt = l(() => {}); const Wt = {}; u(Wt, { "resultValue": () => Me }); async function Me (t) { let { "errorHandle": e } = await Promise.resolve().then(() => (w(), f)); let { "errorStatus": a } = await Promise.resolve().then(() => (S(), I)); return (await e("status")) ? { "status": !0, "result": t, "trace": a.errorList } : { "status": !1, "result": t, "trace": a.errorList }; } const Xt = l(() => {}); const Yt = {}; u(Yt, { "defaultValues": () => Te }); let Te; const te = l(() => { Te = { "mode": "current", "region": "scotland", "startDate": "2025-01-01", "endDate": "2025-01-02" }; }); const ee = {}; u(ee, { "initialValue": () => Je }); async function Je (t) { let { "conditionCheck": e } = await Promise.resolve().then(() => (g(), d)); let { "isNully": a } = await Promise.resolve().then(() => (v(), L)); let { "errorHandle": r } = await Promise.resolve().then(() => (w(), f)); let { "defaultValues": i } = await Promise.resolve().then(() => (te(), Yt)); let n = (await a(t)) ? {} : t; let s = {}; if (await e(n, "object", 1)) { let o = Object.keys(n); let m = Object.keys(i); if (o.length <= m.length) { for await (let c of m)o.includes(c) ? s[c] = n[c] : o.includes(c) === !1 && (s[c] = i[c]); return s; } else return await r(5465, "initialValue"), !1; } else return await r(7899, "initialValue"), !1; } const ae = l(() => {}); return (async function pt (t) { let { "getAPI": e } = await Promise.resolve().then(() => (Qt(), Gt)); let { "conditionCheck": a } = await Promise.resolve().then(() => (g(), d)); let { "baseInput": r } = await Promise.resolve().then(() => (M(), B)); let { "errorHandle": i } = await Promise.resolve().then(() => (w(), f)); let { "resultValue": n } = await Promise.resolve().then(() => (Xt(), Wt)); let { "errorStatus": s } = await Promise.resolve().then(() => (S(), I)); let { "initialValue": o } = await Promise.resolve().then(() => (ae(), ee)); let m = await o(t); if (await a(m, "object")) { let c = await r(m); if (!(await i("status"))) return !1; if (c) { let p = new Date(c.startDate).getTime(); let h = new Date(c.endDate).getTime(); if (p < h) { let y = await e(c); return y ? await n(y) : (await i(8964, "gridRegional"), await n(s.lastError)); } else return await i(9567, "gridRegional"), await n(s.lastError); } else return await i(6534, "gridRegional"), await n(s.lastError); } else return await i(6573, "gridRegional"), await n(s.lastError); })(apiConfig); }